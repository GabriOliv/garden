---
sidebar_position: 1
title: Cap√≠tulo 3
description: CT-TAS - Cap√≠tulo 3 - Preparando-se para a Automa√ß√£o de Teste
tags: [stageA, istqb, cttas, capitulo]
draft: false
---

# 3 Preparando-se para a Automa√ß√£o de Teste

### 3.1 Integra√ß√£o entre os N√≠veis de Teste

### 3.1.1 Diferenciar as distribui√ß√µes de automa√ß√£o de teste

Pir√¢mide inicial:
- BASE Unidade (Componente)
- MEIO Servi√ßo
- TOPO Interface de Usu√°rio

√â preciso desenhar o estado da pir√¢mide atual e o estado desej√°vel.

- Pir√¢mide
	- Distribui√ß√£o equilibrada
	- Testes est√°veis de unidade permitem valida√ß√µes r√°pidas e baixo custo
	- √â O ESTADO ALVO IDEAL
- Cone de Sorvete
	- Vers√£o invertida do ideal
	- √â o mais caro de automatizar
	- Defeitos s√£o encontrados tarde no sistema
- Ampulheta
	- S√£o maiores em testes de unidade e interface
	- Resulta em maiores problemas gerados nas integra√ß√µes do software
	- √â o pior para l√≥gica de neg√≥cio em que se fornece API
- Guarda-Chuva
	- Depende totalmente de testes caros de interface
	- Retorno lento de defeitos
	- Caso seja irrevers√≠vel, o foco deve ser otimizar e reduzir o custo de execu√ß√£o

| N√≠vel | Tipo de Teste | Pir√¢mide | Cone de Sorvete | Ampulheta | Guarda-Chuva |
| :----- | :-----: | -----: | -----: | -----: | -----: |
`TOPO` | Teste de UI | Baixo üü© | Alto üü• | Alto üü• | Alto üü• |
`MEIO` | Testes de Servi√ßo | M√©dio üüß | M√©dio üüß | Baixo üü© | Baixo üü© |
`BASE` | Teste de Unidade | Alto üü• | Baixo üü© | Alto üü• | Baixo üü© |

### 3.1.2 Selecionar uma abordagem de automa√ß√£o de teste com base na arquitetura do sistema em teste

Determinar o estado atual.

Determinar o estado esperado.

O estado final deve ser realista, mesmo que a pir√¢mide seja o ideal.

Ex:

Guarda-Chuva --> Pir√¢mide (Irrealista)

Guarda-Chuva --> Ampulheta (Realista)

Guarda-Chuva --> Cone de Sorvete (Realista)

- Levar em considera√ß√£o:
	- cultura da empresa;
	- maturidade da engenharia.

### 3.1.3 Demonstrar maneiras de otimizar a distribui√ß√£o da automa√ß√£o de teste para alcan√ßar as abordagens Shift Left e Shift Right

Primeiramente, √© necess√°rio escolher o "o qu√™" e o "como".

- Criando a defini√ß√£o de:
	- Estrat√©gia;
	- Escopo.

Ent√£o, √© necess√°rio saber a prioridade do backlog dos itens.

- Shift Left:
	- mover os testes para mais cedo.
- Shift Right:
	- entender as prefer√™ncias do usu√°rio;
	- mover os testes para mais tarde;
	- usar monitoramento de performance do usu√°rio.

Libera√ß√£o de Features:
- Canary:
	- Lan√ßamento para alguns usu√°rios selecionados;
	- Lan√ßamento gradual.
- Dark Launches:
	- Lan√ßamento oculto para todos;
	- Libera√ß√£o aos poucos.

### 3.2 Considera√ß√µes estrat√©gicas em diferentes Modelos de Ciclo de Vida de Desenvolvimento de Software

### 3.2.1 Explicar como os projetos de automa√ß√£o de teste est√£o em conformidade com o modelo de ciclo de vida de desenvolvimento de software legado

- Modelo Cascata:
	- Os testes v√™m depois da implementa√ß√£o,
	- Diminuindo o ROI da automa√ß√£o.
- Modelo V:
	- Planejamento de teste ocorre em fases iniciais,
	- Melhorando o ROI da automa√ß√£o,
	- Mesmo que o TAS ocorra mais tarde.

### 3.2.2 Explicar como os projetos de automa√ß√£o de teste est√£o em conformidade com as pr√°ticas recomendadas de desenvolvimento √°gil de software que d√£o suporte √† automa√ß√£o de teste

- Objetivo √Ågil: alcan√ßar automa√ß√£o de teste in-sprint.
	- Determinar todas as atividades de automa√ß√£o como crit√©rios de sa√≠da para cada user story:
		- Defini√ß√£o de casos de teste;
		- Implementa√ß√£o dos casos de teste automatizados;
		- Atualiza√ß√£o do TAF;
		- Integra√ß√£o com o CI/CD.

Se uma equipe n√£o est√° MADURA do ponto de vista √ÅGIL, segue os passos:
- 1. Primeira Sprint, tentar aplicar:
	- Testes in-sprint;
	- Automatiza√ß√£o atrasada.
- 2. Segunda Sprint, tentar aplicar:
	- Testes in-sprint;
	- Automatiza√ß√£o in-sprint.

### 3.2.3 Preparar-se para projetos de automa√ß√£o de teste em conformidade com as pr√°ticas recomendadas de DevOps que suportam a automa√ß√£o de teste em testes cont√≠nuos

√änfase na implementa√ß√£o de casos de teste automatizados de n√≠vel inferior.

- Foco em testes de base:
	- componentes;
	- componentes integrados;
	- contratos.
- Pois s√£o:
	- r√°pidos;
	- sem depend√™ncia de servi√ßo real;
	- podem ser executados a cada atualiza√ß√£o.

Testes E2E e API devem ser executados separadamente no pipeline.

- Testes Manuais focam em:
	- Testes explorat√≥rios;
	- Coment√°rios de usu√°rio final;
	- Atividade complementar.

### 3.3 Aplicabilidade e Viabilidade da Automa√ß√£o de Teste

### 3.3.1 Explicar os crit√©rios para determinar a adequa√ß√£o dos testes para a automa√ß√£o de teste

Os casos de teste que devem ser automatizados devem ser escolhidos pelo analista de teste ou TAE.

- Crit√©rios:
	- √â tecnicamente poss√≠vel?
	- Possui desafio t√©cnico que pode afetar a entrega?
	- ROI adequado?
	- Valor ao executar os casos com frequ√™ncia?
	- Qual o tipo de teste?
	- Caso repet√≠vel?
	- √â f√°cil de manter quando o SUT atualiza?
	- Abrange fluxo comercial?
	- H√° sobreposi√ß√£o que permite reutiliza√ß√£o de dados?

### 3.3.2 Identificar os desafios que somente a automa√ß√£o de teste pode resolver

Existem testes que s√≥ podem ser realizados com automa√ß√£o.

- Categorias de Automa√ß√£o:
	1. Tempo de execu√ß√£o manual maior que o adequado;
	2. Execu√ß√£o de teste sincronizada;
	3. Testes precisam estar em pipeline;
	4. Arquivos grandes precisam ser analisados;
	5. Precis√£o no tempo dos testes;
	6. Testes iguais executados em diferentes navegadores, sistemas...;
	7. Grande volume de testes para cobertura;
	8. Teste n√£o funcional que precisa de monitoramento.

### 3.3.3 Identificar condi√ß√µes de teste que s√£o dif√≠ceis de automatizar

Testes dif√≠ceis ou imposs√≠veis de automatizar.

- Categorias sem Automa√ß√£o:
	- Valida√ß√£o de requisitos de design de interface;
	- Caso de teste que envolva muita intera√ß√£o humana;
	- Dificuldades t√©cnicas que bloqueiam atividades de automa√ß√£o;
	- Condi√ß√µes que demoram muito tempo.

---