---
sidebar_position: 1
title: Softwares Cont√≠nuos e seu Dilema com Testes Manuais
description: Por que softwares ongoing n√£o podem depender apenas de testes manuais para garantir qualidade?
tags: [stageA, notes, qa, theory, unit_testing, test_planning, quality_assurance, prevention, automation, quality_management, regression_testing, manual_testing]
draft: false
---

# {frontMatter.title}

{frontMatter.description}<br />

---

## O Dilema do Crescimento Sustent√°vel

No desenvolvimento de software, existe uma diferen√ßa fundamental entre projetos "on demand" e "ongoing" que muitas equipes ignoram at√© que seja tarde demais. Softwares "on demand" s√£o aqueles desenvolvidos para atender uma necessidade espec√≠fica, com escopo definido e ciclo de vida previs√≠vel - o cliente paga pela solu√ß√£o e o produto √© entregue. J√° os softwares "ongoing" s√£o sistemas em constante evolu√ß√£o, com funcionalidades sendo adicionadas, modificadas e mantidas continuamente - o cliente paga para utilizar o software e o produto √© melhorado eternamente. Para o primeiro caso, testes manuais podem ser suficientes. Para o segundo, s√£o uma armadilha que transforma o desenvolvimento em um jogo de Jenga infinito, onde cada nova pe√ßa pode derrubar toda a torre.

## Desenvolvimento de Software como Torre de Jenga

Para entender melhor o porqu√™ de testes manuais serem inadequados para softwares "ongoing", imagine o desenvolvimento como uma torre de Jenga infinita. Cada nova feature que adicionamos √© como colocar um novo bloco no topo da torre (expande o sistema), mas n√£o necessariamente o desestabiliza. O verdadeiro perigo est√° nas modifica√ß√µes em c√≥digos anteriores, que alteramos uma funcionalidade existente, sendo como remover um bloco do meio da torre e recoloc√°-lo no topo.

No Jenga tradicional, quando removemos um bloco, deixamos um buraco na estrutura. A torre pode permanecer de p√© temporariamente, mas sua estabilidade est√° comprometida. No desenvolvimento de software, esse "buraco" representa os potenciais defeitos e regress√µes criados quando modificamos c√≥digo existente. Outras partes do sistema dependiam daquele bloco estar exatamente onde estava, e agora precisamos verificar se a aus√™ncia dele (modifica√ß√£o no c√≥digo) n√£o causou instabilidade.

Os testes manuais s√£o como tentar validar a estabilidade da torre olhando para ela e balan√ßando levemente algumas partes. √â lento, impreciso e imposs√≠vel de fazer para toda a estrutura a cada movimento. Os testes unit√°rios, por outro lado, s√£o como ter sensores autom√°ticos em cada conex√£o da torre que imediatamente detectam qualquer instabilidade e preenchem instantaneamente os buracos deixados pelas modifica√ß√µes. Em segundos, voc√™ sabe se sua altera√ß√£o comprometeu a estrutura e pode corrigir o problema antes que a torre desmorone.

A diferen√ßa √© que, ao contr√°rio do Jenga tradicional, onde o objetivo √© derrubar a torre na vez de outra pessoa, no desenvolvimento de software queremos que ela permane√ßa est√°vel infinitamente, crescendo continuamente. Sem testes unit√°rios, cada modifica√ß√£o se torna um risco existencial para todo o sistema.

A realidade √© que testes manuais funcionam apenas quando o volume de funcionalidades √© gerenci√°vel e est√°tico. Quando um software est√° em constante mudan√ßa, a necessidade de validar toda a regress√£o a cada nova altera√ß√£o se torna um gargalo insustent√°vel. √â aqui que os testes unit√°rios deixam de ser uma "boa pr√°tica" e se tornam uma necessidade estrat√©gica para a sobreviv√™ncia do projeto.

## O Exemplo Pr√°tico: O Sistema de E-commerce que Cresceu Demais

Imagine um sistema de e-commerce que come√ßou simples: cadastro de produtos, carrinho de compras e checkout. A equipe tinha 3 desenvolvedores e conseguia testar manualmente todas as funcionalidades em cerca de 2 horas antes de cada deploy. O sistema funcionava perfeitamente e os testes manuais pareciam suficientes.

Ap√≥s 6 meses, o sistema evoluiu significativamente. Agora possui: sistema de cupons de desconto, programa de fidelidade, m√∫ltiplos m√©todos de pagamento, c√°lculo de frete com v√°rias transportadoras, gest√£o de estoque em tempo real, integra√ß√£o com marketplace, sistema de recomenda√ß√µes e avalia√ß√µes de produtos. A equipe cresceu para 8 desenvolvedores trabalhando simultaneamente em diferentes funcionalidades.

O que antes levava 2 horas de teste manual, agora leva 2 dias completos. Mas o pior √© que mesmo dedicando 2 dias inteiros, a equipe n√£o consegue mais cobrir todos os cen√°rios poss√≠veis. Um desenvolvedor adiciona uma nova regra de desconto que quebra o c√°lculo de frete. Outro modifica a valida√ß√£o de estoque que interfere no programa de fidelidade. Um terceiro ajusta a API de pagamentos que impacta o sistema de cupons. Cada altera√ß√£o pode afetar m√∫ltiplos pontos do sistema, e os testes manuais simplesmente n√£o conseguem escalar para cobrir todas as combina√ß√µes. Escalar o teste manual com mais pessoas aumenta o custo e a complexidade do planejamento de testes, mas n√£o resolve o problema fundamental: a impossibilidade de garantir que tudo foi testado e validado antes do deploy diariamente.

## Anatomia do Problema: Por Que Vira um Jogo de Jenga

O teste manual em softwares "ongoing" cria um problema exponencial. A cada nova funcionalidade adicionada, n√£o precisamos apenas testar a nova feature, mas tamb√©m validar que ela n√£o quebrou nenhuma das funcionalidades existentes. Se temos N funcionalidades e adicionamos uma nova, teoricamente precisamos fazer N+1 testes. Essa complexidade s√≥ pode ser diminu√≠da quando existe uma Intelig√™ncia de Teste completamente eficaz, o que na pr√°tica √© imposs√≠vel de alcan√ßar apenas com testes manuais. Na pr√°tica, precisamos testar as intera√ß√µes entre funcionalidades, o que nos leva a uma maior complexidade.

No exemplo do e-commerce, com 8 m√≥dulos principais, temos potencialmente 64 combina√ß√µes de intera√ß√µes a serem testadas. Adicione varia√ß√µes de dados, fluxos alternativos e estamos falando de centenas de cen√°rios. Fazer isso manualmente antes de cada deploy √© simplesmente imposs√≠vel. O resultado? A equipe come√ßa a fazer "testes parciais", focando apenas no que foi alterado e em algumas √°reas "cr√≠ticas".

√â exatamente nesse momento que bugs come√ßam a aparecer em produ√ß√£o. Um desenvolvedor faz uma altera√ß√£o "pequena" em uma fun√ß√£o utilit√°ria que √© usada por 15 m√≥dulos diferentes. Ele testa manualmente apenas o m√≥dulo que estava trabalhando. Os outros 14 m√≥dulos? "Provavelmente est√£o funcionando". At√© que n√£o est√£o. E quando o bug √© descoberto em produ√ß√£o, j√° passou semanas, outros desenvolvedores fizeram altera√ß√µes por cima, e identificar a causa raiz vira uma investiga√ß√£o complexa.

## O Papel dos Testes Manuais: Valida√ß√£o, N√£o Substitui√ß√£o

√â importante esclarecer que n√£o √© vi√°vel eliminar por completo os testes manuais. Os testes manuais t√™m um papel crucial e insubstitu√≠vel no ciclo de desenvolvimento, pois s√£o a valida√ß√£o final de requisitos realizada pelos stakeholders. Quando um Product Owner, um cliente ou um usu√°rio final testa manualmente uma funcionalidade, ele est√° validando se o que foi constru√≠do atende realmente √† necessidade de neg√≥cio, se a experi√™ncia do usu√°rio faz sentido e se o fluxo est√° alinhado com as expectativas.

Essa valida√ß√£o humana √© essencial porque captura aspectos que testes automatizados n√£o conseguem: a usabilidade, a intuitividade, a adequa√ß√£o ao contexto real de uso. Um teste unit√°rio pode validar que a fun√ß√£o de c√°lculo de desconto retorna o valor correto, mas n√£o valida se a forma como o desconto √© apresentado na tela faz sentido para o usu√°rio final. Um teste automatizado pode confirmar que o fluxo de checkout funciona tecnicamente, mas n√£o avalia se o processo √© confuso ou frustrante.

O problema n√£o √© a exist√™ncia dos testes manuais, mas sim sua utiliza√ß√£o como √∫nico ou principal m√©todo de valida√ß√£o t√©cnica. Quando a equipe de desenvolvimento depende de testes manuais para validar regress√µes e garantir que o c√≥digo n√£o quebrou funcionalidades existentes, o sistema se torna insustent√°vel. Os testes manuais devem ser a camada final de valida√ß√£o de neg√≥cio, n√£o a rede de seguran√ßa t√©cnica que impede o sistema de desmoronar.

A estrat√©gia ideal combina diferentes n√≠veis de teste: testes unit√°rios automatizados para validar componentes individuais e prevenir regress√µes, testes de integra√ß√£o para validar a comunica√ß√£o entre m√≥dulos, e testes manuais para validar requisitos de neg√≥cio e experi√™ncia do usu√°rio. Cada tipo de teste tem seu prop√≥sito espec√≠fico, e nenhum substitui completamente o outro. A quest√£o √© n√£o sobrecarregar os testes manuais com responsabilidades que deveriam ser automatizadas.

## Testes Unit√°rios como Rede de Seguran√ßa

Testes unit√°rios resolvem esse problema invertendo a l√≥gica de valida√ß√£o. Em vez de testar o sistema inteiro manualmente ap√≥s cada mudan√ßa, cada componente individual possui testes automatizados que validam seu comportamento esperado. Quando um desenvolvedor modifica uma fun√ß√£o, os testes unit√°rios de todas as funcionalidades que dependem dela s√£o executados automaticamente em segundos.

No nosso exemplo do e-commerce, cada m√≥dulo teria seus pr√≥prios testes unit√°rios. O m√≥dulo de desconto teria testes para todas as regras de c√°lculo. O m√≥dulo de frete teria testes para cada transportadora e cen√°rio. Quando um desenvolvedor altera a fun√ß√£o de c√°lculo de pre√ßo total, 150 testes unit√°rios s√£o executados em 30 segundos, validando automaticamente que nenhuma regress√£o foi introduzida. Se algo quebrou, o desenvolvedor descobre imediatamente, enquanto o contexto da altera√ß√£o ainda est√° fresco em sua mente.

Al√©m disso, testes unit√°rios servem como documenta√ß√£o viva do sistema. Um novo desenvolvedor pode ler os testes do m√≥dulo de cupons e entender melhor quais s√£o as regras de neg√≥cio em volta dele, casos especiais e valida√ß√µes necess√°rias. Os testes se tornam uma especifica√ß√£o execut√°vel que nunca fica desatualizada, porque se ficasse, os testes falhariam.

A implementa√ß√£o de testes unit√°rios deve ser incremental e pragm√°tica. N√£o √© necess√°rio ter 100% de cobertura do dia para a noite. Comece pelas √°reas mais cr√≠ticas e com maior taxa de mudan√ßa. Estabele√ßa a regra de que todo c√≥digo novo deve vir com testes. Gradualmente, refatore c√≥digo legado adicionando testes quando for fazer manuten√ß√µes. Em 6 meses, voc√™ ter√° uma cobertura significativa que transforma a din√¢mica de desenvolvimento.

## Escalando com Confian√ßa

Softwares "ongoing" n√£o s√£o projetos com linha de chegada definida. S√£o sistemas vivos que evoluem continuamente, e precisam de pr√°ticas que suportem esse crescimento sustent√°vel. Testes manuais t√™m seu lugar para valida√ß√µes explorat√≥rias, testes de usabilidade e verifica√ß√µes finais antes de releases importantes. Mas n√£o podem ser a √∫nica ou principal estrat√©gia de qualidade.

Quando uma equipe depende exclusivamente de testes manuais, o desenvolvimento se torna cada vez mais lento e arriscado. O medo de quebrar algo existente paralisa a inova√ß√£o. Desenvolvedores come√ßam a evitar refatora√ß√µes necess√°rias porque "se est√° funcionando, melhor n√£o mexer". A d√≠vida t√©cnica se acumula. O tempo entre identifica√ß√£o de um bug e sua corre√ß√£o aumenta. A velocidade de entrega de novas funcionalidades diminui. O sistema se torna um Jenga gigante onde ningu√©m quer ser o respons√°vel por derrubar a torre.

Testes unit√°rios invertem essa din√¢mica. Com uma boa cobertura de testes, refatorar c√≥digo se torna seguro. Alterar funcionalidades n√£o aumenta exponencialmente o tempo de valida√ß√£o. Bugs s√£o detectados em minutos, n√£o em dias. A equipe ganha confian√ßa para fazer mudan√ßas ousadas. A velocidade de desenvolvimento gasto na escrita de testes √© ganho na manuten√ß√£o, acelerando o trabalho do desenvolvedor, porque menos tempo √© gasto corrigindo regress√µes e mais tempo √© investido em criar valor.

## Por Que Testes Unit√°rios S√£o Negligenciados?

Se testes unit√°rios s√£o t√£o fundamentais para a sustentabilidade de softwares "ongoing", por que a maioria das equipes ainda n√£o os adota? A resposta n√£o est√° na falta de reconhecimento da import√¢ncia, mas na aus√™ncia de educa√ß√£o adequada sobre como implement√°-los e mant√™-los efetivamente.

### O Ensino Focado em Constru√ß√£o, N√£o em Sustentabilidade

A educa√ß√£o em desenvolvimento de software tem um vi√©s estrutural: ensina como construir, mas n√£o como sustentar. Cursos de programa√ß√£o, bootcamps e at√© gradua√ß√µes focam em ensinar como criar funcionalidades (como adicionar novos blocos no topo da nossa torre de Jenga). Os alunos aprendem sintaxe, frameworks, padr√µes de arquitetura e boas pr√°ticas de c√≥digo. Eles saem capacitados para implementar features, integrar APIs e resolver problemas t√©cnicos complexos.

O que n√£o aprendem √© como garantir que o que constru√≠ram continuar√° funcionando quando outros desenvolvedores modificarem o c√≥digo. N√£o aprendem que software n√£o √© apenas um conjunto de funcionalidades que funcionam individualmente, mas um sistema interdependente onde cada mudan√ßa pode ter efeitos colaterais imprevis√≠veis. A diferen√ßa entre "fazer funcionar" e "fazer funcionar sustentavelmente" raramente √© abordada na forma√ß√£o inicial.

Quando testes unit√°rios s√£o mencionados, geralmente s√£o apresentados como "boa pr√°tica" opcional, n√£o como parte fundamental na manuten√ß√£o. O resultado s√£o desenvolvedores que sabem criar c√≥digo, mas n√£o sabem garantir sua longevidade.

### Teoria Sem Manuten√ß√£o Pr√°tica

Os cursos espec√≠ficos de testes unit√°rios cometem um erro diferente, mas igualmente problem√°tico. Eles ensinam a sintaxe dos frameworks de teste, como estruturar testes e como alcan√ßar cobertura, mas n√£o preparam os desenvolvedores para a realidade mais complexa: o que fazer quando os testes come√ßam a falhar.

Quando um desenvolvedor modifica c√≥digo e 15 testes unit√°rios come√ßam a falhar, ele enfrenta uma decis√£o cr√≠tica: a falha indica um bug no c√≥digo novo ou os testes est√£o desatualizados? Como distinguir entre uma regress√£o leg√≠tima e um teste que precisa ser atualizado? Como refatorar testes legados que se tornaram dif√≠ceis de manter? Essas quest√µes pr√°ticas, que surgem inevitavelmente em projetos reais, raramente s√£o abordadas na educa√ß√£o de desenvolvedores.

A consequ√™ncia √© que muitos desenvolvedores, ao enfrentarem testes "flaky" ou dif√≠ceis de manter, simplesmente os removem ou ignoram. Eles n√£o foram preparados para lidar com a manuten√ß√£o cont√≠nua que testes unit√°rios exigem. N√£o compreendem que testes tamb√©m s√£o c√≥digo e, como tal, precisam ser refatorados, otimizados e mantidos. A falta dessa compreens√£o transforma testes unit√°rios de solu√ß√£o em problema, criando a falsa impress√£o de que "atrapalham mais do que ajudam".

### A Confus√£o Entre Testes E2E e Testes Unit√°rios

No mundo de Quality Assurance, existe um movimento compreens√≠vel de automatizar testes manuais atrav√©s de testes end-to-end (E2E). Ferramentas como Selenium, Cypress e Playwright permitem que QAs automatizem fluxos completos de usu√°rio, reduzindo o trabalho manual repetitivo. Essa √© uma evolu√ß√£o natural e ben√©fica para testes de aceita√ß√£o.

O problema surge quando essa abordagem √© apresentada como equivalente ou substituta aos testes unit√°rios. Testes E2E automatizam o mesmo tipo de valida√ß√£o que seria feito manualmente, de verificar se o sistema completo funciona do ponto de vista do usu√°rio. S√£o excelentes para validar requisitos de neg√≥cio e fluxos cr√≠ticos, mas s√£o inadequados como rede de seguran√ßa para desenvolvedores.

Testes E2E s√£o lentos, de manuten√ß√£o cara, fr√°geis (dependem de m√∫ltiplos componentes funcionando simultaneamente) e dif√≠ceis de debugar (quando falham, n√£o indicam especificamente onde est√° o problema). Quando um desenvolvedor modifica uma fun√ß√£o e um teste E2E falha 10 minutos depois, ele perdeu o contexto imediato da altera√ß√£o. J√° quando 15 testes unit√°rios falham em 5 segundos, ele sabe exatamente qual componente foi afetado.

E2E deve ser focada naturalmente na perspectiva do usu√°rio final. Aprender a automatizar valida√ß√µes de neg√≥cio, n√£o diretamente, cria redes de seguran√ßa para desenvolvimento. Isso cria uma lacuna onde testes E2E s√£o implementados pensando em resolver o problema de sustentabilidade que apenas testes unit√°rios podem resolver adequadamente.

### Estamos Despreparados para a Realidade

Essa combina√ß√£o de fatores, habilidade focada em somente constru√ß√£o, habilidades de teste que n√£o abordam manuten√ß√£o pr√°tica, e confus√£o entre tipos de teste, produz profissionais tecnicamente competentes mas despreparados para a sustentabilidade de longo prazo. Eles sabem fazer c√≥digo funcionar, mas n√£o sabem garantir que continue funcionando.

Quando esses profissionais se deparam com a necessidade real de testes unit√°rios em projetos "ongoing", n√£o t√™m o conhecimento pr√°tico necess√°rio para implement√°-los efetivamente. O resultado s√£o tentativas frustradas que refor√ßam a percep√ß√£o de que "testes unit√°rios s√£o complicados demais" ou "n√£o vale a pena". Na realidade, o problema n√£o est√° nos testes unit√°rios, mas na educa√ß√£o inadequada sobre como utiliz√°-los.

A solu√ß√£o passa por reconhecer que desenvolvimento sustent√°vel √© uma disciplina diferente de desenvolvimento funcional, com conhecimentos e pr√°ticas espec√≠ficas que precisam ser ensinadas explicitamente. N√£o √© suficiente saber programar; √© preciso saber programar de forma que outros possam modificar o c√≥digo com seguran√ßa. Isso √© o que diferencia um software que evolui com confian√ßa de um que vive √† beira do colapso.

## Como Come√ßar a Implementar

Se voc√™ est√° em um projeto "ongoing" que depende principalmente de testes manuais, √© hora de mudar. N√£o espere o sistema crescer tanto que a mudan√ßa se torne imposs√≠vel. Comece pequeno: escolha o m√≥dulo mais cr√≠tico do seu sistema e escreva testes unit√°rios para ele esta semana. Estabele√ßa a cultura de que pull requests precisam incluir testes. Documente exemplos de como escrever bons testes unit√°rios no seu projeto.

Para gestores e l√≠deres t√©cnicos: aloquem tempo no planejamento para cria√ß√£o de testes. N√£o trate isso como "overhead" ou "trabalho extra", mas como parte indissoci√°vel do desenvolvimento. Um desenvolvedor que entrega c√≥digo sem testes em um software "ongoing" n√£o entregou uma funcionalidade completa, entregou uma bomba-rel√≥gio.

A pergunta n√£o √© "podemos nos dar ao luxo de escrever testes unit√°rios?", mas sim "podemos nos dar ao luxo de n√£o escrever?". Em softwares "ongoing", a resposta √© clara: testes unit√°rios n√£o s√£o luxo, s√£o investimento em sustentabilidade. S√£o a diferen√ßa entre um sistema que escala com confian√ßa e um jogo de Jenga infinito onde cada mudan√ßa pode ser a √∫ltima.

---

## Mapa Mental

- üèóÔ∏è **Tipos de Software**
	- üì¶ On Demand
		- Escopo definido
		- Ciclo previs√≠vel
	- üîÑ Ongoing
		- Evolu√ß√£o cont√≠nua
		- Funcionalidades em crescimento
- ‚ö†Ô∏è **Problema Central**
	- Cada modifica√ß√£o deixa o sistema mais inst√°vel
	- Testes manuais n√£o escalam junto com o software
- üö´ **Limita√ß√µes dos Testes Manuais**
	- Escala somente com mais testadores
	- Imposs√≠vel testar todas as combina√ß√µes
	- Risco de testes parciais
	- Desenvolvimento fica lento e arriscado
- üë• **Papel dos Testes Manuais**
	- Valida√ß√£o de requisitos de neg√≥cio
	- Valida√ß√£o de usabilidade e intuitividade
	- N√£o deve funcionar como rede de seguran√ßa t√©cnica
- ‚ú® **Solu√ß√£o Testes Unit√°rios**
	- Detec√ß√£o autom√°tica de regress√µes
	- Valida√ß√£o r√°pida
	- Documenta√ß√£o viva como especifica√ß√£o execut√°vel
	- Possibilita refatora√ß√£o segura
- ü§î **Por Que S√£o Negligenciados**
	- Educa√ß√£o com foco em constru√ß√£o, n√£o em sustentabilidade
	- Teoria vs Pr√°tica
	- E2E n√£o substitui testes unit√°rios
	- Despreparo para realidade de manuten√ß√£o cont√≠nua
- üöÄ **Implementa√ß√£o Pr√°tica**
	- Come√ßar com m√≥dulos cr√≠ticos
	- Cultura nos PRs com testes obrigat√≥rios
	- Investimento de tempo no planejamento
	- Tempo gasto em testes √© ganho em manuten√ß√£o

---

## Refer√™ncias

- Artigos:
	- NIKOLOVA, Zornitsa. Testing Strategies in an Agile Context. In: *THE FUTURE OF SOFTWARE QUALITY ASSURANCE*. 2020. p. 111-121.
		- [https://doi.org/10.1007/978-3-030-29509-7_9](https://doi.org/10.1007/978-3-030-29509-7_9)
		- Investir em automa√ß√£o √© essencial para o sucesso a longo prazo. Testes unit√°rios ajudam o desenvolvedor a receber feedback imediato e os bugs s√£o removidos rapidamente como parte do processo regular de desenvolvimento.
	- VOCKE, Ham. Practical Test Pyramid. *martinfowler.com*. Publicado em: 26 fevereiro 2018. Dispon√≠vel em: [https://martinfowler.com/articles/practical-test-pyramid.html#End-to-endTests](https://martinfowler.com/articles/practical-test-pyramid.html#End-to-endTests). Acesso em: 26 nov. 2025.
		- Um grande benef√≠cio dos testes unit√°rios √© que eles servem como uma rede de seguran√ßa para altera√ß√µes de c√≥digo.
- Livros:
	- CRISPIN, Lisa; GREGORY, Janet. *Agile Testing: A Practical Guide for Testers and Agile Teams*. Addison-Wesley, 2009.
		- Testes manuais n√£o s√£o o bastante para alcan√ßar qualidade de software, pois configura somente um dos quadrantes de teste.
	- ADZIC, Gojko. *Specification by Example: How Successful Teams Deliver the Right Software*. Manning Publications, 2011.
		- Com ciclos de entrega curtos (semanas ou at√© dias), testes manuais extensivos s√£o imposs√≠veis. Os testes ent√£o se acumulam no final de uma itera√ß√£o e transbordam para a pr√≥xima, interrompendo o fluxo. A automa√ß√£o de testes funcionais remove esse gargalo e engaja testadores com desenvolvedores, motivando-os a participar da mudan√ßa de processo.
	- MESZAROS, Gerard. *xUnit Test Patterns: Refactoring Test Code*. Addison-Wesley Professional, 2007.
		- Testes manuais s√£o longos e complexos com m√∫ltiplas condi√ß√µes devido √† sobrecarga envolvida na configura√ß√£o das pr√©-condi√ß√µes de cada teste.

---